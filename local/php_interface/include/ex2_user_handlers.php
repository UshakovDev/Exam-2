<?php

/**
 * Обработчики для [ex2-600] Работа с авторами.
 * Задачи:
 * 1. Отследить смену пользовательского поля «Класс пользователя» (список).
 * 2. При успешном обновлении отправить письмо EX2_AUTHOR_INFO с новыми значениями.
 */
class Ex2UserHandlers
{
    /**
     * Буфер для хранения старого значения класса пользователя.
     * Ключ - ID пользователя, значение - массив ['OLD' => ID класса, 'OLD_TEXT' => текст класса].
     * Заполняется в OnBeforeUserUpdate, используется в OnAfterUserUpdate.
     * После использования обязательно очищается, чтобы не тащить значение в следующий вызов.
     */
    protected static $buffer = [];

    /**
     * OnBeforeUserUpdate: сохраняем текущее значение поля перед обновлением и проверяем входные данные.
     * Выполняется ДО сохранения изменений пользователя в базу данных.
     * 
     * Что делает:
     * 1. Извлекаем ID пользователя из массива $fields.
     * 2. Если ID корректен, загружаем текущее значение класса из БД и сохраняем в буфер.
     * 3. Если в запросе пришло новое значение UF_USER_CLASS, нормализуем его (приводим к ID варианта списка).
     *    Это важно: Bitrix может передать массив или строку, нам нужен только ID для сохранения.
     * 4. Возвращаем true, чтобы обновление продолжилось (мы не отменяем операцию).
     */
    public static function onBeforeUserUpdate(array &$fields)
    {
        // Извлекаем ID пользователя, приводим к int для безопасности
        $userId = (int)($fields['ID'] ?? 0);
        if ($userId > 0) {
            // Загружаем текущий класс пользователя из БД и сохраняем в буфер
            // Это нужно, чтобы потом сравнить со значением после обновления
            self::$buffer[$userId] = self::fetchUserClass($userId);
            
            // Если в запросе пришло новое значение класса, нормализуем его
            // normalizeValue() возвращает массив ['VALUE' => ID, 'TEXT' => текст]
            // Нам нужен только ID для сохранения в БД (поле не множественное)
            if (isset($fields['UF_USER_CLASS'])) {
                $fields['UF_USER_CLASS'] = self::normalizeValue($fields['UF_USER_CLASS'])['VALUE'];
            }
        }
        return true; // Разрешаем обновление продолжиться
    }

    /**
     * OnAfterUserUpdate: обновление прошло, отправляем письмо при смене класса.
     * Выполняется ПОСЛЕ успешного сохранения изменений пользователя в базу данных.
     * 
     * Что делает:
     * 1. Проверяем, что обновление было успешным (не отменено другими обработчиками).
     * 2. Извлекаем старое значение класса из буфера (которое сохранили в OnBefore).
     * 3. Получаем новое значение класса (из результата события или из БД, если не пришло).
     * 4. Сравниваем старое и новое значения по ID.
     * 5. Если класс изменился - отправляем письмо EX2_AUTHOR_INFO с текстовыми значениями.
     * 6. Очищаем буфер, чтобы не тащить данные в следующий вызов.
     */
    public static function onAfterUserUpdate(array &$fields)
    {
        // Извлекаем ID пользователя
        $userId = (int)($fields['ID'] ?? 0);
        
        // Если ID некорректен или обновление было отменено (RESULT === false),
        // очищаем буфер и выходим - письмо не отправляем
        if ($userId <= 0 || (isset($fields['RESULT']) && $fields['RESULT'] === false)) {
            unset(self::$buffer[$userId]);
            return;
        }

        // Извлекаем старое значение класса из буфера (которое сохранили в OnBefore)
        // Если по какой-то причине его нет, используем пустые значения
        $old = self::$buffer[$userId] ?? ['OLD' => null, 'OLD_TEXT' => ''];
        // Очищаем буфер сразу после использования
        unset(self::$buffer[$userId]);

        // Получаем новое значение класса:
        // - если в $fields есть UF_USER_CLASS, нормализуем его (получаем ID и текст)
        // - если нет, загружаем из БД (на случай, если поле не обновлялось, но мы всё равно проверим)
        $new = isset($fields['UF_USER_CLASS']) ? self::normalizeValue($fields['UF_USER_CLASS']) : self::fetchUserClass($userId);
        
        // Сравниваем старое и новое значения по ID (приводим к int для надёжности)
        // Если класс изменился (старый ID ≠ новый ID), отправляем письмо
        if ((int)$old['OLD'] !== (int)$new['VALUE']) {
            // Отправляем письмо с текстовыми значениями (для плейсхолдеров #OLD_USER_CLASS# и #NEW_USER_CLASS#)
            self::sendNotification($userId, $old['OLD_TEXT'], $new['TEXT']);
        }
    }

    /**
     * Загружает текущее значение класса пользователя из базы данных.
     * 
     * Что делает:
     * 1. Получает данные пользователя по ID через CUser::GetByID.
     * 2. Извлекает значение поля UF_USER_CLASS (может быть ID варианта списка или null).
     * 3. Нормализует значение через normalizeValue() - получает ID и текстовое представление.
     * 4. Возвращает массив ['OLD' => ID класса, 'OLD_TEXT' => текст класса].
     * 
     * Если пользователь не найден или поле пустое, возвращает ['OLD' => null, 'OLD_TEXT' => ''].
     */
    protected static function fetchUserClass($userId)
    {
        // Загружаем данные пользователя из БД
        $res = CUser::GetByID($userId);
        if ($data = $res->Fetch()) {
            // Извлекаем значение поля UF_USER_CLASS (это ID варианта списка или null)
            $value = $data['UF_USER_CLASS'];
            // Нормализуем значение - получаем массив ['VALUE' => ID, 'TEXT' => текст]
            $normalized = self::normalizeValue($value);
            // Возвращаем в формате, который ожидает наш буфер
            return ['OLD' => $normalized['VALUE'], 'OLD_TEXT' => $normalized['TEXT']];
        }

        // Если пользователь не найден, возвращаем пустые значения
        return ['OLD' => null, 'OLD_TEXT' => ''];
    }

    /**
     * Нормализует значение пользовательского поля-списка к единому формату.
     * 
     * Bitrix может передать значение в разных форматах:
     * - ID варианта списка (число или строка)
     * - Массив ['VALUE' => ID, ...]
     * - Многоуровневый массив
     * 
     * Что делает:
     * 1. Если значение - массив, извлекает ID (проверяет ключ 'VALUE' или берёт первый элемент).
     * 2. Если значение пустое (null, '', 0), возвращает ['VALUE' => null, 'TEXT' => ''].
     * 3. Загружает вариант списка через CUserFieldEnum::GetList по ID.
     * 4. Возвращает массив ['VALUE' => ID варианта, 'TEXT' => текстовое значение].
     * 
     * Если вариант не найден, возвращает ['VALUE' => null, 'TEXT' => ''].
     */
    protected static function normalizeValue($value)
    {
        // Если значение пришло в виде массива, извлекаем ID
        if (is_array($value)) {
            // Проверяем ключ 'VALUE', если нет - берём первый элемент массива
            $value = $value['VALUE'] ?? reset($value);
            // Если первый элемент тоже массив, рекурсивно извлекаем значение
            if (is_array($value)) {
                $value = $value['VALUE'] ?? reset($value);
            }
        }

        // Если значение пустое (null, '', 0, false), возвращаем пустой результат
        if (empty($value)) {
            return ['VALUE' => null, 'TEXT' => ''];
        }

        // Загружаем вариант списка из таблицы b_user_field_enum по ID
        // CUserFieldEnum::GetList возвращает вариант с полями ID и VALUE (текст)
        $enum = CUserFieldEnum::GetList([], ['ID' => (int)$value])->Fetch();
        
        // Если вариант найден, возвращаем ID и текст, иначе - пустые значения
        return $enum ? ['VALUE' => (int)$enum['ID'], 'TEXT' => (string)$enum['VALUE']] : ['VALUE' => null, 'TEXT' => ''];
    }

    /**
     * Отправляет почтовое событие EX2_AUTHOR_INFO с данными о смене класса пользователя.
     * 
     * Что делает:
     * 1. Формирует массив данных для письма:
     *    - USER_ID - ID пользователя
     *    - OLD_USER_CLASS - текст старого класса (для плейсхолдера #OLD_USER_CLASS#)
     *    - NEW_USER_CLASS - текст нового класса (для плейсхолдера #NEW_USER_CLASS#)
     * 2. Вызывает CEvent::Send, который:
     *    - Находит шаблон письма с кодом 'EX2_AUTHOR_INFO'
     *    - Заменяет плейсхолдеры #OLD_USER_CLASS# и #NEW_USER_CLASS# на переданные значения
     *    - Добавляет событие в очередь отправки (таблица b_event)
     * 
     * Примечание: письмо не отправляется сразу, а попадает в очередь.
     * Реальная отправка происходит через агент CEvent::CheckEvents() или вручную из админки.
     */
    protected static function sendNotification($userId, $oldText, $newText)
    {
        // Отправляем почтовое событие EX2_AUTHOR_INFO
        // Параметры: код события, ID сайта, массив данных для подстановки в шаблон
        CEvent::Send('EX2_AUTHOR_INFO', SITE_ID, [
            'USER_ID' => $userId,              // ID пользователя (для возможной подстановки в шаблон)
            'OLD_USER_CLASS' => $oldText,      // Текст старого класса - заменит #OLD_USER_CLASS# в шаблоне
            'NEW_USER_CLASS' => $newText,      // Текст нового класса - заменит #NEW_USER_CLASS# в шаблоне
        ]);
    }
}


